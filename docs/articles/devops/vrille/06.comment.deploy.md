---
title: "Chapitre 3 : Le déploiement"
summary: "Pourquoi arrive-t-on aux limites du DevOps ? Comme pour tout, le temps fait son œuvre. La démarche DevOps n'y échappe pas. Vous pouvez avoir une démarche très aboutie, au bout de plusieurs mois ou plusieurs années, celle-ci aura naturellement du plomb dans l'aile."
authors:
    - Philippe Morisseau
date: 2021-12-20
---

Maintenant que nous avons réussi à **builder** notre application, comment faire pour déployer notre applications et tous ses composants (infra., microservices,...) correctement ?

Comment faire pour stopper le processus de déploiement applicatif si le déploiement d'un des composants échoue ?

Comment m'assurer de pouvoir faire un rollback de mon application et seulement les composants impactés à tout moment ?

## La conceptualisation du processus de déploiement

Pour commencer, il nous faut un référentiel de **déploiement**. 

### Le référentiel de déploiement

Ce référentiel aura pour unique but d'identifier chaque composant à déployer de notre application, avec :

- le nom du composant (du **repository Git**)
- les dépendances du composant

!!! sample "exemple"
    Imaginons 2 applications web : **WebFront** et **WebBack**. **WebFront** dépend de **WebBack**. Et tous les deux dépendent de l'**infra** qui va les héberger. 

    Voici ce que pourrait donner notre référentiel au format **yaml** :

    ```yaml
    components:
    - name: webfront
      dependencies:
      - webback
    - name: webback
      dependencies: 
      - infra
    ```

Ce référentiel va évoluer au fur et à mesure des itérations pour déployer ou décommissioner les composants de l'application. Et donc, tout comme notre référentiel de build, nous allons mettre notre référentiel de **déploiement** dans le même **repository**.

### Le processus de déploiement

Imaginons qu'il y a une mise à jour du référentiel de **build**, ce qui implque qu'il y a eu une mise à jour d'un composant, le processu de build va nous générer un nouveau manifeste avec l'ensemble des pipelines de CI/CD de chaque composant.
A partir de ce manifeste, pour notre environnement cible et pour chaque composant, il faut déterminer :

- s'il n'est pas nécessaire de le déployer (dans le cas d'une librairie par exemple) : il n'y aura donc rien à faire,
- s'il a déjà été déployé : il n'y aura donc rien à faire,
- s'il y a une mise à jour à déployer : il faudra déclencher le déploiement du composant,
- s'il y a eu une erreur lors du déployement d'une dépendance : il ne faudra pas lancer le déploiement.

Encore une fois (comme pour le **build**), c'est comme un arbre où chaque composant correspond à un noeud.

!!! sample "exemple"
    Imaginons que durant notre **sprint** nous ayons fait évoluer nos composants B, D, G. 
    Ci-dessous les arbres de dépendances correspondants :
    ![tree](../../../img/06.comment.deploy.001.svg)

    Lors de l'exécution de notre "meta" pipeline pour passer notre application à l'état buildé, le manifeste indique que des pipelines CI/CD ont été déclenché pour les composants B, D, G mais aussi pour les compasants E, F, I, J et K. Ensuite pour passer notre application à l'état déployé sur notre environnement, il faudra :

    - Ignorer les composants A, B, C, D, E, F, G et H qui n'ont pas besoin d'être déployé,
    - Ignorer les composants L et M qui ont été déjà déployé,
    - Déployer les composants D, I, K et J.
    
    Si durant le processus, le déployement du composant K est en échec, alors il faudra veiller à stopper le processus et ne pas déployer les composants dépendants. Le composant J est donc bloqué par son prédécesseur le composant K.

Notre déploiement applicatif peut se représenter sous la forme du processus ci-dessous : 

![process](../../../img/06.comment.deploy.002.svg)

Le processus va parcourir le référentiel de déploiement en commençant par ceux qui n'ont pas de dépendance, puis par ceux qui dépendent de ces premiers, et ainsi de suite. 

!!! note
    Je vous recommande d'utiliser des processus parallèles pour parcourir l'arbre.

!!! sample "exemple" 
    Si on reprend notre exemple ci-dessus, on aura par ordre de passage :

    1. L
    2. D, I et K
    3. M et J

Pour chaque composant,

1. on recherche le composant dans le manifeste pour obtenir le pipeline associé,
2. on vérifie si celui-ci a déjà été correctement déployé (déterminé par l'état du pipeline).
  
!!! note
    Comme il est possible que le déploiement du composant ne se passe pas correctement, il faut prévoir la possibilité de relancer le déploiement en échec ultérieurement.

2. si oui, on passe au composant suivant,
3. si non, on déclenche le déploiement du composant.
4. on attend la fin du déploiement et on récupère le résultat.
5. si le déploiement est OK, on passe au composant suivant.
6. si le déploiement est KO, on stoppe le déploiement des composants dépendants.

Une fois le référentiel totalement parcouru, on peut déterminer l'état de notre application. Si tous les composants ont été correctement déployés, alors on peut considérer que notre application est correctement déployée.

Si nous avons 3 environnements : DEV, UAT et PROD. Nous pourrons passer notre application de l'état "Buildé" à "Déployé en DEV".

![statemachine](../../../img/06.comment.deploy.003.svg)

Le passage aux états "Déployé en UAT" et "Déployé en PROD" suivront le même processus.

![statemachine](../../../img/06.comment.deploy.004.svg)

### L'effet inattendu 

Afin de pouvoir déployer nos composants, nous devons en plus des référentiels de **build** et de déploiement générer un manifeste afin d'identifier de façon unique les instances de pipelines de chacun des composants.

A chaque fois que nous executons notre meta-pipeline, nous avons une nouveau manifeste qui sera généré au passage à l'état **buildé** de notre application. 

![applicationstate](../../../img/06.comment.deploy.005.svg)

Nous avons donc une image exacte de notre application avec :

- le code de nos différents composants,
- la configuration de ceux-ci porté par le pipeline de CI/CD de chacun des composants,
- la façon dont on doit builder les composants (référentiel de **build**),
- la façon dont on doit déployer tous les composants.

Donc, ce manifeste va aussi nous permettre de pouvoir faire un rollback sur un environnement donnée.  

## Conclusion

L'utilisation conjointe du manifeste et du référentiel de dépendance de déploiement, nous permet d'assurer le déploiment de tous les composants de notre architecture micro-service en limitant les risques d'oubli ou d'échec en cascade. 

De plus, le manifeste généré durant la phase de **build** de notre meta-pipeline nous permet aussi de pouvoir redéployer rapidement notre architecture micro-service à l'état exacte d'une version précédente de notre application.

Tout ça est beau mais reste purement théorique. Pour prouver la valeur de notre idée, je vous présenterais dans la prochaine et dernière partie :

- notre implémentation,
- notre expérimentation et 
- nos retours d'expériences. 

A suivre...

## Références


## Remerciements

_Rédigé par Philippe MORISSEAU, Publié le 04 Janvier 2022_