---
title: "Chapitre 2 : Le DevOps"
summary: "Pourquoi arrive-t-on aux limites du DevOps ? La démarche DevOps comme on peut la comprendre dans la littérature trouve ses limites dans le des projets microservices complexes."
authors:
    - Philippe Morisseau
date: 2021-10-11
---

## Le DevOps

La démarche DevOps comme on peut la comprendre dans la littérature trouve ses limites dans le des projets microservices complexes.

Imaginons que nous avons un nouveau projet d'application basé sur une architecture microservice plutôt complexe. Ce projet souhaite avoir une démarche "Full" DevOps.
J'utilise régulièrement le terme de Full DevOps pour indiquer qu'il n'y a aucun livrable du projet qui ne soit pas intégré entièrement dans la démarche DevOps. 
Cela inclus : le GitOps, le DevSecOps, le Dev{andMore}Ops, le MLOps, le DataOps,...
Nous définissons les règles suivantes :

1. L’infrastructure, le code, la documentation : Tout doit être déployé automatiquement => "Full DevOps"
2. En cas de souci lors du déploiement d’un composant les composants dépendants doivent être bloqués.
3. Ne déployer en UAT que ce qui a été validé en DEV.
4. Ne déployer en PROD que ce qui a été validé en UAT.
5. Utiliser le branching model TBD.

### L’infrastructure, le code, la documentation : Tout doit être déployé automatiquement.

Comme je suis un fana. d'Azure, on va imaginer que notre projet de microservices doit être déployé sur des services managés Azure.
Il faudra donc déployer cet infrastructure pour pouvoir ensuite déployer nos microservices.
Notre équipe produisant de la documentation (spécifications, schéma d'architecture, ...), on souhaite avoir la démarche DevOps pour mettre à jour notre documentation sur un portail.

![code, infra, doc](../../../img/02.pourquoi.ledevops.001.svg)

Pour arriver à cette fin nous allons nous appuyer sur les **repository** git.

- Notre infrastructure sera décrite en **InfraAsCode** avec **Terraform**, **Bicep** ou **ARM json**.
- Nos libraires seront dans réparties dans des **repository** en fonction de leur utilisation. Il n'est pas pertinent de mettre dans un repo a part une libraire qui n'est destinée qu'à un seul microservice.
- Nos microservices (application web, batch, services, ...) seront dans réparties dans des **repository**.

Dans chacun de ces **repository** nous aurons le code (IaC ou code "classic"), mais aussi notre documentation décrite en **DocAsCode** avec **Markdown**, **AsciiDoc** ou **reStructuredText**.

Enfin pour chacun de ces **repository** nous allons mettre en place un pipeline de CI/CD afin d'automatiser la compiliation, la validation et le déploiement à chaque commit.

![git](../../../img/02.pourquoi.ledevops.002.svg)

Jusqu'ici, tout va bien.

### Les dépendances

Le premier souci que l'on peut rencontrer ce trouve au niveau des dépendances de build.
En effet, une libraire créée dans le cadre d'un projet et qui aurait son propre **repository** est pensée pour être utilisée par plusieurs microservices ou par d'autres libraires.
Ce qui implique que des microservices et des libraires peuvent dépendre de libraires. On pourra pas compiler un microservice si les libraires qui sont utilisé par celui-ci ne sont pas disponibles.

C'est ce que j'appel : **la dépendance de compilation**. 

!!! example
    - La **Lib2** utilise la **Lib1**,
    - Le **Batch1** utilise la **Lib1**,
    - Les **WebService1**, **WebService2** et **Batch2** utilisent la **Lib2**
    ![dépendance de compilation](../../../img/02.pourquoi.ledevops.003.svg)

Afin de garantir la robustesse de ma solution, je veux m'assurer qu'une évolution sur une libairie, ne va pas provoquer une regression sur les composants (libraires et microservices) qui dépendent d'elle.
Dans mon pipeline je vais donc mettre en place un **trigger** sur ma libraire.

!!! example


A contrario, si le pipeline CI/CD de notre **Lib2** vient à échouer, je veux 

## En résumé

Bien que les **feature flag** permettent en partie de résoudre nos problématiques, elles ne sont pas à elles seules la réponse à notre problématique de mise en place du DevOps dans une architecture microservice complexe.
Très souvent, pour des raisons économiques évidentes, les **feature flags** sont mises de coté.

Ne pouvant pas forcément réduire encore plus nos délais, il faudra donc se concentrer sur la multitude des déploiements à réaliser (en automatique) en veillant à ne pas oublier une partie !

Nous verrons dans le prochain chapitre que la démarche DevOps peut elle aussi apporter au projet son lot de problématiques.

A suivre...

## Références

- [Martin Fowler - Feature Toggles (aka Feature Flags)](https://martinfowler.com/articles/feature-toggles.html)

## Remerciement

- [Michael Maillot](https://twitter.com/michael_maillot) : pour la relecture
- [Laurent Mondeil](https://www.linkedin.com/in/laurent-mondeil-0a87a743/) : pour la relecture

_Rédigé par Philippe MORISSEAU, Publié le 04 Octobre 2021_
